# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Computes correlation update when swapping pairs
#'
#' @param sol_mat Solution matrix
#' @param swap_idx Indices to swap
#' @param male_snp_idx Male SNP indices
#' @param female_snp_idx Female SNP indices
#'
#' @return Correlation vector update
#'
#' @noRd
NULL

#' Computes energy differential between states
#'
#' @param curr_cor Current correlation
#' @param target_cor Target correlation
#' @param delta_cor Correlation update
#'
#' @return Energy differential
#'
#' @noRd
NULL

#' Evaluates energy of current state
#'
#' @param curr_cor Current correlation
#' @param target_cor Target correlation
#'
#' @return Energy value
#'
#' @noRd
NULL

#' Automatically determine initial temperature for simulated annealing
#'
#' @name auto_init_temp
#'
#' @param sol_mat Current solution matrix
#' @param snp_pairs SNP pair data (male_idx, female_idx, target_cor)
#' @param female_swap_idx Columns to swap in solution
#' @param num_samples Number of random moves to sample
#' @param accept_ratio Target initial acceptance ratio (default: 0.8)
#'
#' @return Recommended initial temperature
#'
#' @noRd
NULL

#' Performs simulated annealing to optimize matching
#'
#' @param sol_mat Solution matrix to optimize
#' @param snp_pairs SNP pair data [male_idx, female_idx, target_cor]
#' @param female_swap_idx Columns to swap in solution
#' @param max_iterations Maximum iterations to run
#' @param temp_decay Temperature decay rate
#' @param init_temp Initial temperature
#' @param auto_temp_samples Number of samples to draw for determining initial
#'   temperature of simulated annealing algorithm
#' @param auto_accept_ratio Desired initial acceptance ratio for calibration of
#'   initial temperature value in simulated annealing algorithm
#' @param collect_diagnostics If TRUE, collect diagnostic metrics
#' @param quietly If TRUE, suppress output messages
#'
#' @return Optimized solution matrix and optional metrics
optim_matching <- function(sol_mat, snp_pairs, female_swap_idx, num_iterations = 10000L, temp_decay = 0.995, init_temp = 1e-9, auto_temp_samples = 100000L, auto_accept_ratio = 0.995, collect_diagnostics = FALSE, quietly = TRUE) {
    .Call(`_amsimr_optim_matching`, sol_mat, snp_pairs, female_swap_idx, num_iterations, temp_decay, init_temp, auto_temp_samples, auto_accept_ratio, collect_diagnostics, quietly)
}

#' Extend (or construct) the pedigree matrix for a generation
#'
#' Constructs a pedigree matrix for the provided generation of size (L * n)
#' where L is the pedigree depth and n is the population size. If the current
#' pedigree depth is L, the oldest layer is discarded. If the current pedigree
#' is an empty matrix, initialises the pedigree.
#'
#' @param pedigree_current The pedigree of the current generation to extend
#' @param matching Integer vector of length n, where matching[i] specifies the
#'   index of the mate of individual i in the population
#' @param pedigree_depth
#'
#' @return An extended pedigree for the current generation
#'
#' @noRd
NULL

#' Compute the pedigree distance between individuals
#'
#' Computes the distance between two individuals in the population pedigree
#' graph given their index identifiers and the pedigree using the LCA algorithm
#' for DAGs. Returns the maximum integer value if a common ancestor is not
#' found.
#'
#' @param pedigree The population pedigree
#' @param ind1_id Index of the first individual
#' @param ind2_id Index of the second individual
#'
#' @return The pedigree distance between ind1 and ind2, or the maximum integer
#'   value if no common ancestor is found.
#'
#' @noRd
NULL

