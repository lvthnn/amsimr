// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>

//' Compute update vector for correlation vector of assortative trait pairs.
//'
//' @param sol The current state matrix
//' @param swap Indices of swapped pairs
//' @param phi_m Male phenotype indices
//' @param phi_f Female phenotype indices
//' @return Update vector for correlation vector of assortative trait pairs
//[[Rcpp::export]]
arma::vec compute_delta(const arma::mat &sol, const arma::uvec &swap,
                        const arma::uvec &phi_m, const arma::uvec &phi_f) {
  arma::uvec rswap = arma::reverse(swap);
  arma::mat phimat_m = sol.submat(swap, phi_m);
  arma::mat phimat_f = sol.submat(rswap, phi_f) - sol.submat(swap, phi_f);
  arma::vec res = arma::sum(phimat_m % phimat_f, 0).t();

  Rcpp::Rcout << "---------------------" << std::endl
              << "swap" << std::endl
              << swap << std::endl
              << "phimat_m" << std::endl
              << phimat_m << std::endl
              << "phimat_f" << std::endl
              << phimat_f << std::endl
              << "res" << std::endl
              << res << std::endl
              << "--------------------" << std::endl;
  return res;
}

//' Compute the energy differential between proposal state and current state
//'
//' @param rho_sol
//' @param delta
//' @param rho
//' @return Energy differential between proposed state and current state
//[[Rcpp::export]]
double dpsi(const arma::vec &rho_sol, const arma::vec &delta,
            const arma::vec &rho) {
  return arma::dot(delta, delta) + 2 * arma::dot(rho_sol - rho, delta);
}

//' Evaluate the energy of a state
//'
//' @param sol The current state matrix
//' @param swap Indices of swapped pairs
//' @param phi_m Male phenotype indices
//' @param phi_f Female phenotype indices
//' @return Vector of Î” values for each phenotype pair
//[[Rcpp::export]]
double psi(const arma::vec &rho_sol, const arma::vec &rho) {
  return arma::norm(rho_sol - rho, 2);
}

//' Determine the optimal matching for a given generation.
//'
//' @param sol Initial solution to start annealing algorithm from
//' @param psi_vec Phenotype pairs for avoidance function
//' @param cf_idx Columns to be exchanged when generating proposal states
//' @param n_iter Number of iterations of annealing algorithm
//' @param alpha_temp Temperature decay parameter for annealing algorithm
//' @param eval Return simulation data for verification
//' @return Final state generated by simulated annealing algorithm
// [[Rcpp::export]]
Rcpp::List optim_matching(arma::mat &sol, const arma::mat &psi_vec,
                          const arma::uvec &cf_idx, int n_iter = 10000,
                          double alpha_temp = 1.0, double temp0 = 5.0,
                          bool eval = false) {
  int n = sol.n_rows;
  arma::uvec phi_m = arma::conv_to<arma::uvec>::from(psi_vec.col(0));
  arma::uvec phi_f = arma::conv_to<arma::uvec>::from(psi_vec.col(1));
  arma::vec psi_eval, dpsi_eval, alpha_eval, temp_eval;
  arma::vec rho = psi_vec.col(2);
  double temp = temp0;

  // Compute the assortative trait correlation vector for the initial state
  arma::vec rho_sol = arma::vec(phi_m.n_elem);
  for (int i = 0; i < phi_m.n_elem; i++) {
    arma::mat cor = arma::cor(sol.col(phi_m[i]), sol.col(phi_f[i]));
    rho_sol[i] = cor(0, 0);
  }

  // Run the simulated annealing algorithm
  for (int i = 0; i < n_iter; i++) {
    arma::uvec swap = arma::randi<arma::uvec>(2, arma::distr_param(0, n - 1));
    arma::vec delta_prop = compute_delta(sol, swap, phi_m, phi_f);
    arma::vec rho_prop = rho_sol + delta_prop;

    double dpsi_prop = dpsi(rho_sol, delta_prop, rho);
    double alpha = std::min(1.0, std::exp(-dpsi_prop / temp));
    double unf = Rcpp::as<double>(Rcpp::runif(1));

    if (eval) {
      psi_eval.set_size(n_iter);
      dpsi_eval.set_size(n_iter);
      alpha_eval.set_size(n_iter);
      temp_eval.set_size(n_iter);

      psi_eval[0] = psi(rho_sol, rho);
      dpsi_eval[0] = 0.0;
      alpha_eval[0] = 1.0;
      temp_eval[0] = temp;
    }

    if (unf < alpha) {
      sol.submat(swap, cf_idx) = sol.submat(arma::reverse(swap), cf_idx);
      rho_sol = rho_prop;
    }

    temp *= alpha_temp;

    if (eval) {
      psi_eval[i] = psi(rho_sol, rho);
      dpsi_eval[i] = dpsi_prop;
      alpha_eval[i] = alpha;
      temp_eval[i] = temp;
    }
  }

  if (eval) {
    return Rcpp::List::create(Rcpp::Named("sol") = sol,
                              Rcpp::Named("psi") = Rcpp::wrap(psi_eval),
                              Rcpp::Named("dpsi") = Rcpp::wrap(dpsi_eval),
                              Rcpp::Named("alpha") = Rcpp::wrap(alpha_eval),
                              Rcpp::Named("temp") = Rcpp::wrap(temp_eval));
  } else {
    return Rcpp::List::create(Rcpp::Named("sol") = sol);
  }
}
