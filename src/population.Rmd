---
title: "Dev"
output: html_document
date: "2025-02-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## BSc project

This is a function to generate the population:

```{r}
population <- function(params) {
  #' Generate an initial population
  #'
  #' Generate the 0th generation of a population.
  #' @param params Path to JSON config file with simulation parameters.

  # Retrieve simulation parameters from configuration file
  config <- jsonlite::fromJSON(params)
 
  # Extract relevant parameters 
  n <- config$n_pop
  p <- config$n_gene
  q <- config$n_pheno

  # Simulate sex of individuals, minor allele frequencies and genotypes
  sex <- sample(rep(c(0, 1), n / 2))
  maf <- 0.5 # @TODO: Make into beta / uniform variable
  gene <- matrix(rbinom(n * p, 2, rep(maf, each = n)), nrow = n, ncol = p)

  names(maf) <- paste0("rs", 1:p)
  colnames(gene) <- paste0("rs", 1:p)

  # Generate phenotypes, for now model as function of genotype
  snps_causal <- config$snp_causal
  phi <- matrix(nrow = n, ncol = 0)
  gam_causal <- list()
  
  for (pheno in names(snps_causal)) {
    snp_pheno <- snps_causal[[pheno]]
    gene_snp <- gene[, snp_pheno]
    gam_snp <- matrix(1)# @TODO: Make into variable
    
    names(gam_snp) <- paste0("rs", snp_pheno)
    gam_causal[[pheno]] <- gam_snp
    
    phenos <- gene_snp %*% gam_snp # + rnorm(n, sd = 0.5)
    colnames(phenos) <- pheno
    
    phi <- cbind(phi, phenos)
  }
  
  pop <- data.frame(sex, gene, phi)
  sex <- pop[, "sex"] == 1
  
  # Assemble the population object
  pop <- list(
    pop = pop,
    sex = sex,
    maf_genes = maf,
    gam_causal = gam_causal,
    data = data.frame(sex, gene, phi)
  )
  
  class(pop) <- "population"
  return(pop)
}
```

Here are $\psi: \mathcal S \to \mathbf R$ and $\Delta \psi$ as discussed.

```{r}
dpsi <- function(sol, swap) norm(sol[swap, "phi1"] - sol[rev(swap), "phi1"], type = "2")^2
psi <- function(sol) norm(sol$phi1 - sol$f_phi1, type = "2")^2
```

Here we implement the `sim_matching` function to generate a spouse matching between the male and female subpopulations. Currently, we are only using a single trait $\phi_1$ to select on.

```{r}
sim_matching <- function(pop, iter = 50000, kappa0 = 100, eval = FALSE) {
  # Size of male and female subpopulations
  n <- nrow(pop$data) / 2
  
  # Initial sample -- change this to greedy
  males <- pop$pop[!pop$sex, ]
  females <- pop$pop[pop$sex, ]
  males <- males[order(males$phi1), ]
  females <- females[order(females$phi1), ]
  rownames(males) <- rownames(females) <- 1:n
  colnames(females) <- paste0("f_", colnames(females))
  
  sol <- cbind(males, females)
  
  swaps <- replicate(iter, sample(1:n, size = 2), simplify = FALSE)

  kappa <- kappa0 / log(1 + 1000 * 1:iter)
  
  # Metropolis step
  for (s in 2:iter) {
    if (s %% 1000 == 0) print(s)
    swap <- swaps[[s]]
    
    # Extract this into a function
    alpha_acc <- min(1, exp(-dpsi(sol, swap) / kappa[s]))
    
    # Accept step
    if (runif(1) < alpha_acc) {
      sol[swap] <- sol[rev(swap)]
    }
  }
    
  return(sol)
}


```

Verification

```{r}
# Visualise phenotype as function of genotype (and sex)
plot(pop$pop$rs1 + rnorm(pop$pop |> nrow(), sd = 0.1), pop$pop$phi1,
     col = ifelse(pop$sex, "blue", "orange"))

matching <- data.frame(names(test_matching$sol) |> as.integer(), test_matching$sol,
                       pop$pop[pop$sex, "phi1"], pop$pop[!pop$sex, "phi1"])
colnames(matching) <- c("m", "f", "phi_m", "phi_f")

plot(matching$phi_m + rnorm(50, sd = 0.1), matching$phi_f + rnorm(50, sd = 0.1))

table(matching$phi_m, matching$phi_f)

```
