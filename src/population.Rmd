---
title: "Dev"
output: html_document
date: "2025-02-12"
---

## Simulated annealing implementation

This is a function to generate the population:

```{r}
population <- function(params) {
  #' Generate an initial population
  #'
  #' Generate the 0th generation of a population.
  #' @param params Path to JSON config file with simulation parameters.

  # Retrieve simulation parameters from configuration file
  config <- jsonlite::fromJSON(params)
 
  # Extract relevant parameters 
  n <- config$n_pop
  p <- config$n_gene
  q <- config$n_pheno

  # Simulate sex of individuals, minor allele frequencies and genotypes
  sex <- sample(rep(c(0, 1), n / 2))
  maf <- 0.5
  
  gene <- matrix(rbinom(n * p, 2, rep(maf, each = n)), nrow = n, ncol = p)
  
  names(maf) <- names(gene) <- paste0("rs", 1:p)

  # Generate phenotypes, for now model as function of genotype
  snps_causal <- config$snp_causal
  phi <- matrix(nrow = n, ncol = 0)
  gam_causal <- list()
  
  for (pheno in names(snps_causal)) {
    snp_pheno <- snps_causal[[pheno]]
    gene_snp <- gene[, snp_pheno]
    gam_snp <- matrix(2)
    
    names(gam_snp) <- paste0("rs", snp_pheno)
    gam_causal[[pheno]] <- gam_snp
    
    phenos <- gene_snp %*% gam_snp # + rnorm(n)
    colnames(phenos) <- pheno
    
    phi <- cbind(phi, phenos)
  }
  
  pop <- data.frame(sex, gene, phi)
  
  attr(pop, "maf_genes") <- maf
  attr(pop, "gam_causal") <- gam_causal
  
  return(pop)
}
```

Here are $\psi: \mathcal S \to \mathbf R$ and $\Delta \psi$ as discussed.

```{r}
dpsi <- function(sol, swap) {
  norm(sol[swap, "phi1"] - sol[rev(swap), "phi1"], type = "2")^2
}
psi <- function(sol) norm(sol$phi1 - sol$f_phi1, type = "2")^2
swap_sol <- function(sol, swap) {
  exch_col <- grepl("f_", names(sol))
  sol[swap, exch_col] <- sol[rev(swap), exch_col]
  return(sol)
}
```

Here we implement simulated annealing:

```{r}
sim_matching <- function(pop, iter = 100, kappa0 = 1, greedy = TRUE, eval = FALSE) {
  #' Find an approximately optimal matching between individuals in the population
  #'
  #' @param pop Population data frame
  #' @param iter Number of iterations to
  #' @param
  
  # Size of male and female populations
  n <- nrow(pop) / 2

  # Initial sample -- change this to greedy
  males <- pop[pop$sex == 0, ]
  females <- pop[pop$sex == 1, ]
  if (greedy) {
    males <- males[order(males$phi1), ]
    females <- females[order(females$phi1), ]
  }
  
  rownames(males) <- rownames(females) <- 1:n
  names(females) <- paste0("f_", colnames(females))
  
  # Set up the first sample
  sol <- sol_opt <- cbind(males, females)
  psi_opt <- psi(sol)
  exch_col <- grepl("f_", names(sol))
  
  # Samples for exchanges
  swaps <- replicate(iter, sample(n, size = 2), simplify = FALSE)
  kappa <- kappa0 / (1 + 0.001 * 1:iter)
  
  if (eval) {
    psi_eval <- numeric(iter)
    dpsi_eval <- numeric(iter)
    rho_eval <- numeric(iter)
    psi_eval[1] <- psi(sol)
    dpsi_eval[1] <- 0
    rho_eval[1] <- 1
  }
  
  # Metropolis step
  for (s in 2:iter) {
    swap <- sample(n, size = 2)
    psi_sol <- psi(sol)
    dpsi_sol <- dpsi(sol, swap)
    rho_s <- min(1, exp(-dpsi_sol / kappa[s]))
    
    # Accept step
    if (runif(1) < rho_s) {
      sol[swap, exch_col] <- sol[rev(swap), exch_col]
      if (psi_sol < psi_opt) sol_opt <- sol
    }
    
    if (eval) {
      psi_eval[s] <- psi(sol)
      dpsi_eval[s] <- dpsi_sol
      rho_eval[s] <- rho_s
    }
  }
    
  if (eval) {
    return(list(
      sol = sol,
      sol_opt = sol_opt,
      psi_opt = psi(sol_opt),
      dpsi = dpsi_eval,
      psi = psi_eval,
      rho = rho_eval,
      kappa = kappa
    ))
  } else {
    return(list(
      sol = sol
    ))
  }
}
```

\`Verification

```{r}
set.seed(42)

pop <- population("~/Github/AssocMating/config.json")

test <- sim_matching(pop, iter = 1000, eval = TRUE, greedy = FALSE)
```

```{r}
plot_eval <- function(samps_eval) {
  par(mfrow = c(2, 2))
  plot(samps_eval$psi, type = "l", xlab = "Iteration", ylab = expression(psi))
  plot(samps_eval$dpsi, xlab = "Iteration", ylab = expression(Delta * psi))
  plot(samps_eval$rho, xlab = "Iteration", ylab = "Acceptance probability")
  plot(samps_eval$kappa, type = "l", xlab = "Iteration", ylab = "Temperature")
}

tsol <- test$sol

tsolopt <- test$sol_opt
plot(tsolopt$phi1, tsolopt$f_phi1)

plot_eval(test)
```
